---
title: 'M2.951 Tipologia i cicle de vida de les dades: PRA2'
author: "Autor: Eric Farran- Jordi Alvarez"
date: "2024.1"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
    includes:
      in_header: header.html
  word_document: default
  pdf_document:
    highlight: zenburn
    toc: yes
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)
options(scipen = 999)
```


```{r}

if (!require('stringr')) install.packages('stringr'); library('stringr')
if (!require('VIM')) install.packages('VIM'); library('VIM')
if (!require('readr')) install.packages('readr'); library('readr')
if (!require('dplyr')) install.packages('dplyr'); library('dplyr')

```

\newpage




******
# Descripció del dataset. Perquè és important i quina pregunta/problema pretén respondre?
******
*Resumeix breument les variables que el formen i el seu tamany.*


**RESPOSTA JORDI:** El conjunt de dades top250movies presenta una estructura de 250 observacions i 10 característiques, i classifica les 250 pel·lícules més ben valorades pels usuaris/àries d'una de les bases de dades cinematogràfiques més potents actualment com és la d’*Internet Movie Database* coneguda popularment com IMDb. Aquesta extracció, actualitzada l'11 d'abril del 2024, es va obtenir aplicant tècniques de web scraping de forma responsable i ètica, respectant les condicions de servei d’IMDb i sense sobrecarregar els seus servidors.


Es vol analitzar si, amb els atributs disponibles al dataset, es pot establir relacions entre les valoracions que fixem com a variable de classe, i el gènere de la pel·licula, el director/a, o el pressupost destinat a la seva producció. Addicionalment, es pretén determinar si aquesta valoració comporta una major rendibilitat.


Mostrem a continuació un resum de les variables del dataset, i una mostra del seu contingut, indicant el tipus de dada segons R:


```{r}
# Importació dataset
top250movies <- read.csv('top250movies.csv')
summary(top250movies)
glimpse(top250movies)
```

Breu descripció dels atributs:

+ **Title**: Títol original
+ **Genre**: Conjunt de gèneres
+ **Year**: Any de llançament
+ **Classification**: Classificació en diferents format
+ **Duration**: Durada en hores i minuts
+ **Rating**: Qualificació promig
+ **Review**: Número de ressenyes
+ **Director**: Director o directora
+ **Budget**: Pressupost en moneda local
+ **Collection**: Ingressos de taquillatge totals




******
# Integració i selecció de les dades d’interès a analitzar
******

*Pot ser el resultat adicionar diferents datasets o una subselecció útil de les dades originals, en base a l’objectiu que es vulgui aconseguir. Si es decideix treballar amb una selecció de les dades, és molt important que aquesta estigui degudament justificada. A més, es recomana mostrar un resum de les dades que permeti veure a simple vista les diferents variables i els seus rangs de valors.*

**RESPOSTA JORDI:** Atès que només hi ha disponible una font de dades, per aquest projecte no cal la integració de diferents datasets. Respecte la selecció de característiques de les pel·lícules, la informació de l'any de publicació no es d'interès per a les preguntes a les que es pretén donar resposta.

```{r}
#top250moviesExt<-top250movies[,-1]
#top250movies<-top250movies[,c(1:2,4:10)]
#tail(top250movies)

```


******
# Neteja de les dades.
******

**RESPOSTA JORDI:** Abans d'iniciar el procés de correcció o eliminació de mostres errònies del dataset, comencem depurant algunes variables que contenen informació no pertinent com per exemple el text *"Original title: "* a la variable **Title**, o el text *"(estimated)"* a la variable **Budget**:

```{r}
## Neteja
### Extracció de caràcters superflus
#top250movies.extraction <- function(column,
#                                    pattern){
#  return(str_remove(string = top250movies[[column]],
#                    pattern = pattern))
#}

#top250movies$Title <- top250movies.extraction(column = 'Title',
#                                              pattern = 'Original title:')

#top250movies$Budget <- top250movies.extraction(column = 'Budget',
#                                               pattern = '\\(estimated\\)')

```


```{r}
head(top250movies)
```


##  Les dades contenen zeros, elements buits o altres valors numèrics que indiquin la pèrdua de dades?
*Gestiona cadascun d'aquests casos utilitzant el mètode d'imputació que consideris més adequat.*



##  Identifica i gestiona adequadament el tipus de dada de cada atribut 
*(p.ex. conversió de variables categòriques en factor).*



##  Identifica i gestiona els valors extrems.

##  Justifica la necessitat d'altres mètodes de neteja per a aquest dataset en particular i, de ser necessari, aplica'ls.


## Es defineixen les funcions de neteja


## Es defineixen les funcions de neteja

```{r}
# Eliminació del patró de la columna especificada
  top250movies.remove <- function(column,
                                  pattern){
    result <- str_remove_all(string = top250movies[[column]],
                             pattern = pattern)
    return(result)
  }

# Conversió de la duració a minuts
  top250movies.duration_conversion <- function(duration){
    value <- str_split(string = duration,
                       pattern = ' ')[[1]]
    if(is.na(value[2])){
      if(grepl(pattern = 'h',
               x = value[1])){
        hours <- as.numeric(str_remove_all(string = value[1],
                                           pattern = '[a-z]'))
        minutes <- 0
        }else{
          hours <- 0
          minutes <- as.numeric(str_remove_all(string = value[1],
                                           pattern = '[a-z]'))
      }
      }else{
        hours <- as.numeric(str_remove_all(string = value[1],
                                           pattern = '[a-z]'))
        minutes <- as.numeric(str_remove_all(string = value[2],
                                           pattern = '[a-z]'))
      }
    time <- hours*60 + minutes
    return(time)
  }

# Conversió dels reviews en unitats
  top250movies.review_conversion <- function(review){
    if(grepl(pattern = 'K',
             x = review)){
      units <- paste(str_remove_all(string = review,
                                    pattern = '[^0-9]'),
                     '000',
                     sep = '')
      }else{
        if(grepl(pattern = '\\.',
                 x = review)){
          units <- paste(str_remove_all(string = review,
                                        pattern = '[^0-9]'),
                         '00000',
                         sep = '')
          }else{
            units <- paste(str_remove_all(string = review,
                                          pattern = '[^0-9]'),
                           '000000',
                           sep = '')}
      }
    return(units)
  }

# Conversió del pressupost en dòlars
  top250movies.dollar_conversion <- function(monetary_units){
    if(is.na(monetary_units)){
      conversion <- NA
    }else{
    conversion_value <- subset(Monetary_conversion_policy,
                               subset = Local == str_replace_all(string = monetary_units,
                                                                 pattern = '[0-9]|\\,|\\s',
                                                                 replacement = ''),
                               select = Dolar,
                               drop = TRUE)
    value <- as.numeric(str_replace_all(string = monetary_units,
                                        pattern = '[^0-9]',
                                        replacement = ''))
    conversion <- value*conversion_value
    }
    return(conversion)
  }

# Proporció de valors perduts en la columna
  top250movies.na_prop <- function(column){
    value <- subset(x = top250movies,
                    select = column,
                    drop = TRUE)
    result <- cat(column,
               ': ',
               round(x = sum(is.na(value))/length(value),
                     digits = 3)*100,
               '%',
               '\n',
               sep = '')
    return(result)
  }
  
# Detecció de valors
  top250movies.detect <- function(value,
                                  pattern){
    if(is.na(value)){
      result <- NA
    }else{
      result <- grepl(pattern = pattern,
                      x = value)
    }
    return(result)
  }

# Valoració de la pel·lícula en termes de rendibilitat
  top250movies.is_profitable <- function(minimum_criteria){
    budget <- subset(x = top250movies,
                     select = Budget,
                     drop = TRUE)
    collection <- subset(x = top250movies,
                         select = Collection,
                        drop = TRUE)
    result <- collection-minimum_criteria*budget > 0
    return(result)
  }
  
# Normalització min-max
  top250movies.minmax_norm <- function(column){
    result <- (column - min(column))/(max(column) - min(column))
    return(result)
  }
```

## Eliminació de caràcters superflus

```{r}
# Title
  top250movies$Title <- top250movies.remove(column = 'Title',
                                            pattern = 'Original title:')

# Budget
  top250movies$Budget <- top250movies.remove(column = 'Budget',
                                             pattern = '\\(estimated\\)')
```

## Estandardització

S'observen els valors que pren la característica 'Classification'.

```{r}
# Classification
  top250movies$Classification <- factor(top250movies$Classification,
                                        levels = c('13',
                                                   '18',
                                                   '12',
                                                   'A',
                                                   '16',
                                                   '7',
                                                   'Apta para mayores',
                                                   'PG-13',
                                                   '(Banned)',
                                                   'PG',
                                                   'Passed',
                                                   '14',
                                                   'A/i',
                                                   'T',
                                                   'Not Rated',
                                                   '7/i'),
                                        labels = c('R',
                                                   'R',
                                                   'R',
                                                   'PG',
                                                   'R',
                                                   'PG-13',
                                                   'PG',
                                                   'PG-13',
                                                   'R',
                                                   'PG',
                                                   'PG',
                                                   'PG',
                                                   'PG',
                                                   'R',
                                                   'PG'),
                                        exclude = 'Not Rated')

# Collection
  top250movies$Collection <- top250movies.remove(column = 'Collection',
                                                 pattern = '[^0-9]')

# Gestió d'espais
  top250movies <- as.data.frame(apply(X = top250movies,
                                      MARGIN = c(1,2),
                                      FUN = str_trim,
                                      side = 'both'))
```

## Conversió

```{r}
# Duration
  top250movies$Duration <- mapply(FUN = top250movies.duration_conversion,
                                  duration = top250movies$Duration,
                                  USE.NAMES = FALSE)

# Review
  top250movies$Review <- mapply(FUN = top250movies.review_conversion,
                                review = top250movies$Review,
                                USE.NAMES = FALSE)
  
# Budget
  # Es defineix la política de conversió
  Monetary_conversion_policy <- data.frame('Local' = c('R$',
                                                       'FRF',
                                                       'DKK',
                                                       'DEM',
                                                       'A$',
                                                       '₹',
                                                       '€',
                                                       '₩',
                                                       '¥',
                                                       '£',
                                                       '$'),
                                           'Dolar' = c(0.055,
                                                       0.164261,
                                                       0.14,
                                                       0.0018,
                                                       0.66,
                                                       0.012,
                                                       1.08,
                                                       0.00073,
                                                       0.0064,
                                                       1.26,
                                                       1))
  
  top250movies$Budget <- mapply(FUN = top250movies.dollar_conversion,
                                monetary_units = top250movies$Budget,
                                USE.NAMES = FALSE)
```

## Canvi de tipus de dades

Es modifica la naturalesa dels atributs de la data.

```{r}
# Variables de caràcter enter
  for(i in c('Year', 'Duration', 'Review', 'Budget', 'Collection')){
    top250movies[[i]] <- as.integer(top250movies[[i]])
  }

# Variables de caràcter flotant
  top250movies$Rating <- as.numeric(top250movies$Rating)

# Variables de caràcter factor
  for(i in c('Classification', 'Director')){
    top250movies[[i]] <- as.factor(top250movies[[i]])
  }
```

## Transformacions dicotòmiques

```{r}
# Genre
  genre_list <- unique(str_trim(unlist(strsplit(top250movies$Genre,
                                               split = ','))))
  genre_list <- genre_list[!is.na(genre_list)]
  
  for(i in genre_list){
    top250movies[[paste('Is_',
                     i,
                     sep = '')]] <-
      mapply(FUN = top250movies.detect,
             value = top250movies$Genre,
             pattern = i,
             USE.NAMES = FALSE)
    
  }
```

## Valors extrems

Es cerquen i suprimeixen valors extrems per a les variables Budget i Collection. Totes les altres variables de caràcter numèric es consideren que contenen valors legítims.

```{r}
for(i in colnames(top250movies)){
  if(i %in% c('Budget', 'Collection')){
    outlier <- boxplot(top250movies[[i]])$out
    top250movies[[i]][top250movies[[i]] %in% outlier] <- NA}
  }
```

## Imputació

Primerament es cerca la proporció de valors perduts per característica.

```{r}
for(column in colnames(top250movies)){
  top250movies.na_prop(column)
}
```

S'adverteix que la proporció de valors perduts no supera en cap cas el 19%. Per tant es procedeix amb la imputació per k-NN considerant només el gènere, l'any, el rating i el review. 

```{r}
# Imputació per k-NN
  for(i in colnames(top250movies)){
    if(anyNA(top250movies[[i]])){
      top250movies <- kNN(data = top250movies,
                          variable = i,
                          metric = 'grower',
                          dist_var = c('Is_Drama',
                                       'Is_Crime',
                                       'Is_Action',
                                       'Is_Biography',
                                       'Is_History',
                                       'Is_Adventure',
                                       'Is_Western',
                                       'Is_Romance',
                                       'Is_Sci-Fi',
                                       'Is_Fantasy',
                                       'Is_Mystery',
                                       'Is_Family',
                                       'Is_Thriller',
                                       'Is_War',
                                       'Is_Comedy',
                                       'Is_Animation',
                                       'Is_Music',
                                       'Is_Horror',
                                       'Is_Film-Noir',
                                       'Is_Musical',
                                       'Is_Sport',
                                       'Year',
                                       'Rating',
                                       'Review'),
                          imp_var = FALSE)
    }
  }
```

## Generació de noves característiques

```{r}
# S'obtenen els beneficis per a cada pel·lícula
  top250movies$Net_income <- top250movies$Collection - top250movies$Budget

# Es comprova si la pel·lícula és rendible
  top250movies$Profitable <- top250movies.is_profitable(2)
```

## Normalització min-max d'atrbiuts numèrics

Es normalitzen els valors de les característiques numèriques en top250movies d'acord al criteri min-max.

```{r}

top250moviesSenseNormalitzar <- top250movies
  
for(i in colnames(top250movies)){
  if(class(top250movies[[i]]) %in% c('numeric', 'integer') &
     i != 'Year'){
    top250movies[[i]] <- top250movies.minmax_norm(top250movies[[i]])
  }
}
```

```{r}
head(top250movies)
tail(top250movies)
```


******
# Anàlisi de les dades.
******

## Aplica un model supervisat i un no supervisat a les dades i comenta els resultats obtinguts.

### Model supervisat

Triem un mètode de classificació per al model supervisat. Implementem a continuació un arbre de decisió per a crear regles que determinin si una pel·lícula és profitosa o no depenent de les variables independents. Per això, tenim les instàncies correctament etiquetades a la variable de classe dicotòmica "Profitable", generada a partir dels atributs "Budget" i "Collectuion". S'estima que una pel·lícla és profitosa, si la recaudació dobla al pressupost destinat per a la seva producció.

#### Preparació de les dades per al model

Per a la selecció de característiues, excloem, els atributs Títol, Director, Duració perquè hi ha molta varietat en les dades. Els camps Collection i Budget també els excloem perquè son atributs que deriven en la variable objectiu "Profitable".


*Nota Interna [JA]. De moment comento aquestes  línees que calculen el guany d'entropia però em poden ser utils.*

```{r}
#InformationGain <- function( tble ) {
#  tble <- as.data.frame.matrix(tble)
#  entropyBefore <- Entropy(colSums(tble))
#  s <- rowSums(tble)
#  entropyAfter <- sum (s / sum(s) * apply(tble, MARGIN = 1, FUN = Entropy ))
#  informationGain <- entropyBefore - entropyAfter
#  return (informationGain)
#}
```


```{r}
#if (!require('DescTools')) install.packages('DescTools'); library('DescTools')
#cat("Reviews: ", round(InformationGain(table(top250movies[,c('Review', 'Rating')]))*100,2),"%")
```

Fem l'extració en un nou dataset, i conertim els camps lògics que determinen el gènere de la pel·licula a Numèric. A continuació presentem una mostra i fem un resum del subconjunt de dades:

```{r}


top250movies_id3b <- top250moviesSenseNormalitzar[c('Year','Review','Rating','Is_Drama','Is_Crime','Is_Action','Is_Biography','Is_History','Is_Adventure','Is_Western','Is_Romance','Is_Sci-Fi','Is_Fantasy','Is_Mystery','Is_Family','Is_Thriller','Is_War','Is_Comedy','Is_Animation','Is_Music','Is_Horror','Is_Film-Noir','Is_Musical','Is_Sport','Profitable')]


cols.num <- c('Is_Drama','Is_Crime','Is_Action','Is_Biography','Is_History','Is_Adventure','Is_Western','Is_Romance','Is_Sci-Fi','Is_Fantasy','Is_Mystery','Is_Family','Is_Thriller','Is_War','Is_Comedy','Is_Animation','Is_Music','Is_Horror','Is_Film-Noir','Is_Musical','Is_Sport')
top250movies_id3b[cols.num] <- sapply(top250movies_id3b[cols.num],as.numeric)
sapply(top250movies_id3b, class)



varsb <- c('Year','Review','Rating','Is_Drama','Is_Crime','Is_Action','Is_Biography','Is_History','Is_Adventure','Is_Western','Is_Romance','Is_Sci-Fi','Is_Fantasy','Is_Mystery','Is_Family','Is_Thriller','Is_War','Is_Comedy','Is_Animation','Is_Music','Is_Horror','Is_Film-Noir','Is_Musical','Is_Sport')

knitr::kable(head(top250movies_id3b))
summary(top250movies)



```


Per validar l’arbre de decisió, és necessari dividir el conjunt de dades en un conjunt d’entrenament i un conjunt de test. El conjunt d’entrenament serà utilitzat per construir i afinar el model, mentre que el conjunt de test servirà per avaluar la seva precisió.

El més correcte és utilitzar un conjunt de dades diferent del que utilitzem per a construir l’arbre, és a dir, un conjunt diferent del d’entrenament. Utilitzem una proporció de 2/3 per el conjunt d’entrenament i 1/3 per el conjunt de prova.



```{r}
set.seed(666)
y <- top250movies_id3b[,25] 
X <- top250movies_id3b[,c(1:24)]
```

De manera dinàmica, separem les dades en funció del paràmetre *split_prop* amb un valor de 3:

```{r}
split_prop <- 3 
indexes = sample(1:nrow(top250movies_id3b), size=floor(((split_prop-1)/split_prop)*nrow(top250movies_id3b)))
trainX<-X[indexes,]
trainy<-y[indexes]
testX<-X[-indexes,]
testy<-y[-indexes]
```

#### Creació del model
Per a crear l'arbre de decisió, fem ús de la funció C5.0 de la llibreria C50. Els paràmetres que necessita la funció són la matriu de camps predictors (el conjunt d’entrenament X) i el camp classificador (conjunt d’entrenament y):


```{r}
trainy = as.factor(trainy)
model <- C50::C5.0(trainX, trainy,rules=TRUE )
summary(model)
```

El paràmetre Errors mostra el número i percentatge de casos mal classificats en el subconjunt d’entrenament. classifica erròneament 23 dels 166 casos donats, una taxa d’error del 13.9%.


A continuació, visualitzarem el model obtingut les regles obtingudes del model:

```{r}
if (!require('grid')) install.packages('grid'); library('grid')
model <- C50::C5.0(trainX, trainy)
plot(model,gp = gpar(fontsize = 7.0))
```

De l'arbre resultant es conclouen la següent classificació:

+ En un **92%** dels casos, si la pel·licula és igual o anterior al 75, i les ressenyes son iguals o inferiors a les 188000, aleshores, **NO ÉS PROFITOSA**.
+ En canvi, si és superior al 75,  en un **86%** dels casos, la pel·lícula **ÉS PROFITOSA**, encara que el nombre de ressenyes sigui igual o inferior a les 188800.
+ En el cas de superar les 188000 ressenyes, si la pel·lícula és posterior a l'any 64, la pel·lícula **ÉS PROFITOSA** en un **88%** dels casos.
+ En el cas contrari, és a dir, pel·lícules anteriors al 65 que superin les 188000 ressenyes, si la pel·lícula és del gènere de fantasia, **NO ÉS PROFITOSA** en un **78%** dels casos, però en la resta de gèneres,  **ÉS PROFITOSA** en un **93%** dels casos.


Com hem comprovat, el conjunt de dades objecte de l'estudi, treu conclusions molt valuoses que no es poden deduir observant únicament el llistat de les 250 pel·lícules millor valorades per als usuaris d'IMDb.


### Model No supervisat

Per a l'estudi del model no supervisat prescindint inicialment de la variable etiquetada que defineix cada classe, i que en el nostre conjunt correspont a la variable dicotòmica *Profitable* (1 - Rendible/ 0 - No rendible)

Com no sabem d'inici el nombre d'agrupacions o classes naturals al que pertanyen les instàncies, farem us del mètode k-means per agrupar les observacions segons les variables independents disponibles. Per dur-ho a terme, normalitzem els atributs numèrics i avaluarem diferent nombre de clústers (k) aplicant mètriques com SSW (*Sum of Squared Within*), SSB (*Sum of Squared Between*) i el coeficient de *Silhouette*.


+ **SSW** - Homogeneïtat entre grups. Minimització de distàncies intragrup. 
+ **SSB** - Heterogeneïtat entre grups. Maximizació de distàncies intragrup.
+ **Coeficient de Silhouette** - intervals que indiquen si la mostra està al grup correcte.

Sabem que el nombre correcte de k és 2 perquè treballem amb una variable dicotòmica que determina les classes. A continuació estudiem diferents possibilitats.

Abans d'aplicar *K-means*, es esencial normalitzar els valors per assegurar que totes les variables contribueixen equitativament a l'anàlisi. La normalització transforma els valors per tenir una mitjana de 0 i una desviació estàndard de 1.

```{r}
if (!require('ggplot2')) install.packages('ggplot2'); library('ggplot2')
if (!require('cowplot')) install.packages('cowplot'); library('cowplot')
if (!require('ggpubr')) install.packages('ggpubr'); library('ggpubr')


#Seleccionem les variables d'interès i normalitzem
top250movies.all<-top250movies[,c('Profitable','Rating', 'Review', 'Budget', 'Collection')]
top250moviesNormalitzada <- as.data.frame(scale(top250movies.all[,c('Rating', 'Review', 'Budget', 'Collection')]))

top250moviesNormalitzada.cols<-dim(top250moviesNormalitzada)[2]
top250moviesNormalitzada.rows<-dim(top250moviesNormalitzada)[1]

# Mostrem les dimensiones i el nombre d'observacions
print(paste("Nombre de columnes:", top250moviesNormalitzada.cols))
print(paste("Nombre de files:", top250moviesNormalitzada.rows))

# Comprovem la normalització
mean_normalized <- apply(top250moviesNormalitzada, 2, mean)
sd_normalized <- apply(top250moviesNormalitzada, 2, sd)
print("Mitjana de les variables normalitzades:")
print(mean_normalized)
print("Desviacions estàndard de les variables normalitzades:")
print(sd_normalized)


```

La normalització és correcta. Ja es pot procedir a aplicar el mètode *k-means*. Avaluem diferents nombres de clústers (k) per a determinar l'agrupació òptima:

```{r}
# Avaluem k de 1 a 10
distance <- cluster::daisy(top250moviesNormalitzada)
valores <- seq(from=1, to=10, by=1)

# Resultats de les mètriques
resultats_ssw <- rep(NA, length(valores))
resultats_ssb <- rep(NA, length(valores))
resultats_silhouette <- rep(NA, length(valores))

for (k in valores[-1]) {
  set.seed(123)
  model <- stats::kmeans(top250moviesNormalitzada, centers=k)
  clusters <- model$cluster
  resultats_silhouette[k] <- summary(cluster::silhouette(
    clusters, distance))$avg.width
  resultats_ssw[k] <- model$tot.withinss
  resultats_ssb[k] <- model$betweenss
}

resultats_kmeans <- data.frame(valores, resultats_silhouette,
                             resultats_ssw, resultats_ssb) %>%
tidyr::drop_na()

resultats_kmeans

```

Visualització dels resultats. es generen gràfics per a visualitzar les mètriques Coeficient de Silhouette, SSW i SSB per ajudar a escollir el nombre idoni de clústers:

```{r}
# Gràfica del Coeficient de Silhouette
plot_silhouette<-ggplot(data=resultats_kmeans, mapping = aes(x=valores, y=resultats_silhouette))+scale_x_continuous(breaks=valores, minor_breaks = NULL)+
  geom_line(color='red', size=1)+
  geom_vline(aes(xintercept=2), color='green', linetype='dashed', size=1, alpha=0.75)+
  annotate('text',x=2, y=resultats_kmeans$resultats_silhouette[resultats_kmeans$valores==4], label='\n k',color='green', size=4, fontface='bold',hjust=0.0,vjust=0.75)+
  geom_point(color='blue',size=2)+labs(title = 'Gráfica del Coeficiente de Silhouette', x='nº de clusters', y='silhoutte')

# Gràfica de Sum of Squared Within (SSW)
plot_ssw<-ggplot(data=resultats_kmeans, mapping = aes(x=valores, y=resultats_ssw))+scale_x_continuous(breaks=valores, minor_breaks = NULL)+scale_y_continuous(labels=scales::label_scientific(digits=2))+
  geom_line(color='red', size=1)+
  geom_vline(aes(xintercept=5), color='green', linetype='dashed', size=1, alpha=0.75)+
  annotate('text',x=5, y=resultats_kmeans$resultats_ssw[resultats_kmeans$valores==5], label='\n k',color='green', size=4, fontface='bold',hjust=0.0,vjust=0.75)+
  geom_point(color='blue',size=2)+labs(title = 'Gráfica de Sum of Squared Within (SSW)', x='nombre de clústers', y='SSW')

# Gràfica de Sum of Squared Between (SSB)
plot_ssb<-ggplot(data=resultats_kmeans, mapping = aes(x=valores, y=resultats_ssb))+scale_x_continuous(breaks=valores, minor_breaks = NULL)+scale_y_continuous(labels=scales::label_scientific(digits=2))+
  geom_line(color='red', size=1)+
  geom_vline(aes(xintercept=5), color='green', linetype='dashed', size=1, alpha=0.75)+
  annotate('text',x=5, y=resultats_kmeans$resultats_ssb[resultats_kmeans$valores==5], label='\n k',color='green', size=4, fontface='bold',hjust=0.0,vjust=0.75)+
  geom_point(color='blue',size=2)+labs(title = 'Gráfica de Sum of Squared Between (SSB)', x='nº de clusters', y='SSB')

# Es combinen els gràfics en una figura annotada
annotate_figure(
  top = text_grob('k-means | Elecció del paràmetre k', face='bold', size=16),
  ggarrange(plot_silhouette, plot_ssw, plot_ssb, labels=c('A', 'B', 'C'), align='hv', nrow=3, ncol=1)
)

```


A. *Coeficient de Silhouette*: la gràfica mostra com s'ajusta cada punt al clúster assignat. Els valors oscilen entre -1 i 1, on un valor alt indica que els punts estàn ajustats al seu propi grup i lluny dels veins. Hi ha un  pic més pronunciat per a k=2 el que apunta que l'agrupació de 2 classes te un ajustament més adequat en comparació amb els altres valors de k.


B. *SSW*: la gràfica mesura les distàncies al quadrat de cada punt en un clúster al centroide del grup, indicador de la cohesió del clúster. Un valor menor indica que els punts estan més a prop del centroide, fet desitjable. D'acord amb el gràfic, el *SSW* disminueix significativament fins a k=5, i a partir d'aquí, els canvis son menys pronunciats, i no redueix substancialment la variació dins els clústers. 

C. *SSB*: la gràfica mesura la suma de les distàncies al quadrat entre els centroides dels clústers i el centroide global de tots els punts, reflectint la separació entre clústers. Un valor alt indica que els clústers estan més dispersos, i per tant millor definits. Al gràfic s'observa un agument a cada increment de k, però igual que passa amb el *SSW*, el canvi és menys pronunciat després de k=5. Això suggereix que a més clústers afegim, la millora no es tan evident després d'arribar als 5 clústers.

Sorprent els resultats de *SSW* i *SSB*, degut a que el nombre esperat de clústers és 3. Per entendre millor aquests resultats, visualitzem a continuació les agrupacions per a k=2 i K=5 en les diverses combinacions de variables disponibles.

Primer, creem els models *k-means*  per cada valor de k desitjat:


```{r}
# Creem modelo K-means per a k=2 i k=5
set.seed(123)
k2_model <- kmeans(top250moviesNormalitzada, centers=2)
k5_model <- kmeans(top250moviesNormalitzada, centers=5)

```

definim la funció per a crear els gràfics de dispersió:

```{r}

create_kmeans_plot <- function(data, k_model, var1, var2, profitable) {
  ggplot(data, aes(x = .data[[var1]], y = .data[[var2]], 
                   color = factor(k_model$cluster), shape = profitable)) +
    geom_point() +
    labs(title = paste(var1, "vs", var2),
         x = var1, y = var2, color = "Cluster", shape = "Profitable") +
    theme_minimal() +
    theme(text = element_text(size = 7),          
          axis.title = element_text(size = 8),    
          axis.text = element_text(size = 7),      
          legend.title = element_text(size = 7),   
          legend.text = element_text(size = 7),    
          legend.position = "bottom")              
}

combine_plots_with_shared_legend <- function(plots_list, num_columns = 3) {
  # Assumim que tots els gràfics de la llista tenen llegenda, i l'extraiem
  legend_plot <- cowplot::get_legend(plots_list[[1]])
  
  # Combinació dels gràfics sense llegenda
  combined_plots <- cowplot::plot_grid(plotlist = lapply(plots_list, function(p) {
    p + theme(legend.position = "none")
  }), labels = NULL, ncol = num_columns)
  
  # Afegim la llegenda al final dels gràfics combinats
  final_plot <- cowplot::plot_grid(combined_plots, legend_plot, ncol = 1, 
                                   rel_heights = c(10, 1))
  
  # retornem el gràfic final amb la llegenda
  return(final_plot)
}
```


A continuació, utilitzem la funció per a crear els gràfics per a les diferents relacions de parells de variables per a k02 i k=5:

```{r}
if (!require('gridExtra')) install.packages('gridExtra'); library('gridExtra')

# Llista de totesles combinacions de parells de variables:
variable_pairs <- combn(c('Rating', 'Review', 'Budget', 'Collection'), 2, simplify = FALSE)

# Llistes per a guardar els gràfics:
plots_k2 <- list()
plots_k5 <- list()

for(i in seq_along(variable_pairs)) {
  var1 <- variable_pairs[[i]][1]
  var2 <- variable_pairs[[i]][2]

  # Guardem els gràfics a les seves respectives llistes
  plots_k2[[i]] <- create_kmeans_plot(top250movies.all, k2_model, var1, var2, top250movies.all$Profitable)
  plots_k5[[i]] <- create_kmeans_plot(top250movies.all, k5_model, var1, var2, top250movies.all$Profitable)
}

# Exemple d'us de la funció amb plots_k2 i plots_k5
final_plot_k2 <- combine_plots_with_shared_legend(plots_k2)
final_plot_k5 <- combine_plots_with_shared_legend(plots_k5)

# Visualitsem els gràfics finals
print(final_plot_k2)
```

```{r}
print(final_plot_k5)
```


Com s'observa, el nombre de clústers més adient es per a k=2. Per a k=5 hi ha classes que queden superposades. L'elecció de k=2 s'alinea amb la recomanació del coeficient de *Silhouette* que es tracta d'un indicador robust de la qualitat de l'agrupament, i encara que hi ha disminucions marginals per a *SSW* i augments marginals per a SSB després de k=2, aquests no justifiquen l'elecció d'un major nombre de clústers.



## Aplica una prova per contrast d'hipòtesi. 
*Tingues en compte que algunes d'aquestes proves requereixen verificar prèviament la normalitat i homocedasticitat de les dades.*


******
# Representació dels resultats a partir de taules i gràfiques.
******

*Aquest apartat es pot respondre al llarg de la pràctica, sense la necessitat de concentrar totes les representacions en aquest apartat. S'ha de representar tant el contingut del dataset per a observar les proporcions i distribucions de les diferents variables una vegada aplicada l'etapa de neteja, com els resultats obtinguts després de l'etapa d'anàlisi.*


******
# Resolució del problema.
******

*A partir dels resultats obtinguts, quines són les conclusions? Els resultats permeten respondre al problema?*
