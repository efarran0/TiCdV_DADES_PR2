---
title: 'M2.951 Tipologia i cicle de vida de les dades: PRA2'
author: "Autor: Eric Farran- Jordi Alvarez"
date: "2024.1"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
    includes:
      in_header: header.html
  word_document: default
  pdf_document:
    highlight: zenburn
    toc: yes
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)
options(scipen = 999)
```


```{r}

if (!require('stringr')) install.packages('stringr'); library('stringr')
if (!require('VIM')) install.packages('VIM'); library('VIM')
if (!require('readr')) install.packages('readr'); library('readr')
if (!require('dplyr')) install.packages('dplyr'); library('dplyr')
if (!require('pillar')) install.packages('pillar'); library('pillar')
if (!require('ggplot2')) install.packages('ggplot2'); library('ggplot2')
if (!require('ggstats')) install.packages('ggstats'); library('ggstats')
if (!require('grid')) install.packages('grid'); library('grid')
if (!require('gridExtra')) install.packages('gridExtra'); library('gridExtra')
if (!require('cowplot')) install.packages('cowplot'); library('cowplot')
if (!require('ggpubr')) install.packages('ggpubr'); library('ggpubr')
```

\newpage



******
# Descripció del dataset. Perquè és important i quina pregunta/problema pretén respondre?
******

El conjunt de dades top250movies presenta una estructura de 250 observacions i 10 característiques, i classifica les 250 pel·lícules més ben valorades pels usuaris/àries d'una de les bases de dades cinematogràfiques més potents actualment com és la d’*Internet Movie Database* coneguda popularment com IMDb. Aquesta extracció, actualitzada l'11 d'abril del 2024, es va obtenir aplicant tècniques de web scraping de forma responsable i ètica, respectant les condicions de servei d’IMDb i sense sobrecarregar els seus servidors.

En aquest projecte analític, essencialment, es vol estudiar quina relació guarda la rendibilitat de les pel·lícules amb les altres característiques que es recullen en el dataset generat en la pràctica 1. La condició de rendibilitat pels metratges s'esbrinarà més endavant, en l'apartat de generació de noves característiques, considerant només el pressupost, els ingressos totals i un llindar, encara per definir. Aquesta nou atribut el fixarem com a variable de classe, i la resta d'atributs els considerem com a variables independents.

Mostrem a continuació un resum de les variables del dataset, i una mostra del seu contingut, indicant el tipus de dada segons R:


```{r}
# Importació dataset
top250movies <- read.csv('top250movies.csv')
glimpse(top250movies)
```

Breu descripció dels atributs:

+ **Title**: Títol original
+ **Genre**: Conjunt de gèneres
+ **Year**: Any de llançament
+ **Classification**: Classificació en diferents format
+ **Duration**: Durada en hores i minuts
+ **Rating**: Qualificació promig
+ **Review**: Número de ressenyes
+ **Director**: Director o directora
+ **Budget**: Pressupost en moneda local
+ **Collection**: Ingressos de taquillatge totals



******
# Integració i selecció de les dades d’interès a analitzar
******


Atès que només hi ha disponible una font de dades, per aquest projecte no cal la integració de diferents datasets. Respecte la selecció de característiques de les pel·lícules S'ometen el títol, la classificació i  el director de la pel·lícula per considerar-se dades irrellevants en aquest estudi. A més a més, cada títol, i gairebé cada director, és únic al conjunt de dades; això comporta que a no aporti valor afegit a l'anàlisi. 


```{r selection}
names <- colnames(top250movies)
exclude <- c('Title',
             'Classification',
             'Director')
selection <- names[!(names %in% exclude)]

top250movies <- subset(x = top250movies,
                       select = selection)
```


******
# Neteja de les dades.
******

Previ a la depuració, implementem una série de funcions que ens seran d'utilitat al llarg de l'apartat.

## Definició de funcions

```{r function definition}
# Eliminació de patrons
  top250movies.remove <- function(column,
                                  pattern){
    input <- top250movies[[column]]
    result <- str_remove_all(string = input,
                             pattern = pattern)
    return(result)
  }

# Conversió del temps
  top250movies.time_conversion <- function(column){
    input <- top250movies[[column]]
    time <- c()
    for (i in 1:length(input)) {
      value <- str_split(string = input[i],
                         pattern = ' ')[[1]]
      hours <- 0
      minutes <- 0
      if (is.na(value[2])) {
        if (grepl(pattern = 'h',
                  x = value[1])) {
          hours <- as.numeric(str_remove_all(string = value[1],
                                             pattern = '[a-z]'))
          } else {
            minutes <- as.numeric(str_remove_all(string = value[1],
                                                 pattern = '[a-z]'))
            }
        } else {
          hours <- as.numeric(str_remove_all(string = value[1],
                                             pattern = '[a-z]'))
          minutes <- as.numeric(str_remove_all(string = value[2],
                                             pattern = '[a-z]'))
          }
      time[i] <- hours*60 + minutes
      }
    return(time)
    }

# Conversió d'unitats
  top250movies.units_conversion <- function(column){
    input <- top250movies[[column]]
    units <- c()
    for(i in 1:length(input)){
      ifelse(test = grepl(pattern = 'K',
                          x = input[i]),
             yes = units[i] <- paste(str_remove_all(string = input[i],
                                                    pattern = '[^0-9]'),
                                     '000',
                                     sep = ''),
             no = ifelse(test = grepl(pattern = '\\.',
                                      x = input[i]),
                         yes = units[i] <- paste(str_remove_all(string = input[i],
                                                                pattern = '[^0-9]'),
                                                 '00000',
                                                 sep = ''),
                         no = units[i] <- paste(str_remove_all(string = input[i],
                                                               pattern = '[^0-9]'),
                                                '000000',
                                                sep = '')))
    }
    return(units)
  }

# Conversió d'unitats monetàries
  top250movies.dollar_conversion <- function(column,
                                             policy){
    input <- top250movies[[column]]
    conversion <- c()
    for (i in 1:length(input)) {
      ifelse(test = is.na(input[i]),
             yes = conversion[i] <- NA,
             no = conversion[i] <- subset(get(policy),
                                          subset = Local == str_replace_all(string = input[i],
                                                                            pattern = '[0-9]',
                                                                            replacement = ''),
                                          select = Dolar,
                                          drop = TRUE) *
               as.numeric(str_replace_all(string = input[i],
                                          pattern = '[^0-9]',
                                          replacement = '')))
      }
    return(conversion)
    }

# Càlcul de la proporció de valors perduts
  top250movies.na_prop <- function(column){
    input <- top250movies[[column]]
    result <- cat(column,
               ': ',
               round(x = sum(is.na(input))/length(input),
                     digits = 3)*100,
               '%',
               '\n',
               sep = '')
    return(result)
  }
  
# Detecció de patrons
  top250movies.detect <- function(column,
                                  pattern){
    input <- top250movies[[column]]
    result <- as.numeric(grepl(pattern = pattern,
                               x = input))
    return(result)
  }

# Valoració en termes de rendibilitat
  top250movies.is_profitable <- function(minimum_criteria){
    budget <- top250movies[['Budget']]
    collection <- top250movies[['Collection']]
    value <- collection - minimum_criteria * budget > 0
    result <- as.numeric(value)
    return(result)
  }

#Funció per a crear els gràfics de dispersió:

create_kmeans_plot <- function(data, k_model, var1, var2, profitable) {
  ggplot(data, aes(x = .data[[var1]], y = .data[[var2]], 
                   color = factor(k_model$cluster), shape = profitable)) +
    geom_point() +
    labs(title = paste(var1, "vs", var2),
         x = var1, y = var2, color = "Cluster", shape = "Profitable") +
    theme_minimal() +
    theme(text = element_text(size = 7),          
          axis.title = element_text(size = 8),    
          axis.text = element_text(size = 7),      
          legend.title = element_text(size = 7),   
          legend.text = element_text(size = 7),    
          legend.position = "bottom")              
}

combine_plots_with_shared_legend <- function(plots_list, num_columns = 3) {
  # Assumim que tots els gràfics de la llista tenen llegenda, i l'extraiem
  legend_plot <- cowplot::get_legend(plots_list[[1]])
  
  # Combinació dels gràfics sense llegenda
  combined_plots <- cowplot::plot_grid(plotlist = lapply(plots_list, function(p) {
    p + theme(legend.position = "none")
  }), labels = NULL, ncol = num_columns)
  
  # Afegim la llegenda al final dels gràfics combinats
  final_plot <- cowplot::plot_grid(combined_plots, legend_plot, ncol = 1, 
                                   rel_heights = c(10, 1))
  
  # retornem el gràfic final amb la llegenda
  return(final_plot)
}

```

Comencem amb el procés purament de neteja del conjunt de dades. Hem decidit alterar l'ordre de l'enunciat perquè el mètode d'imputació es preferible implementar-lo una vegada les dades son correctes.

## Eliminació de caràcters superflus

S'eliminen els caràcters innecessaris en les columnes del conjunt de dades.

```{r removement}
# Budget
  top250movies$Budget <- top250movies.remove(column = 'Budget',
                                             pattern = '\\(estimated\\)|,|\\s')

# Collection
  top250movies$Collection <- top250movies.remove(column = 'Collection',
                                                 pattern = '[^0-9]')
```

## Conversió

S'expressen d'acord a un mateix critèri els valors dels atributs requerits.

```{r conversion}
# Duration
  top250movies$Duration <- top250movies.time_conversion(column = 'Duration')

# Review
  top250movies$Review <- top250movies.units_conversion(column = 'Review')
  
# Budget
  # Es defineix la política de conversió
  Monetary_policy <- data.frame('Local' = c('R$',
                                            'FRF',
                                            'DKK',
                                            'DEM',
                                            'A$',
                                            '₹',
                                            '€',
                                            '₩',
                                            '¥',
                                            '£',
                                            '$'),
                                'Dolar' = c(0.055,
                                            0.164261,
                                            0.14,
                                            0.0018,
                                            0.66,
                                            0.012,
                                            1.08,
                                            0.00073,
                                            0.0064,
                                            1.26,
                                            1))
  
  top250movies$Budget <- top250movies.dollar_conversion(column = 'Budget',
                                                        policy = 'Monetary_policy')
```

## Canvi de tipus de dades

Es modifica la naturalesa dels atributs del conjunt de dades.

```{r data type}
for (column in colnames(top250movies)) {
  
  # Variables de tipus integer
    if (column %in% c('Year',
                      'Duration',
                      'Review',
                      'Budget',
                      'Collection')) {
      top250movies[[column]] <- as.integer(top250movies[[column]])
    }
  
  # Variables de tipus numeric
    if (column == 'Rating') {
      top250movies[[column]] <- as.numeric(top250movies[[column]])
    }
  
}
```

## Valors extrems

Es cerquen i suprimeixen els valors extrems per a les variables Budget i Collection. Totes les altres variables de caràcter numèric, com per exemple 'Rating', es considera que contenen valors legítims.

```{r extreme values, fig.show = 'hide'}
# Valors extrems
  for (column in colnames(top250movies)) {
    if (column %in% c('Budget',
                      'Collection')) {
      outlier <- boxplot(top250movies[[column]])$out
      top250movies[[column]][top250movies[[column]] %in% outlier] <- NA
      }
    }
```

## Imputació

Primerament es cerca la proporció de valors perduts per a cada característica.

```{r data losed}
# Proporció de dades perdudes
  for (column in colnames(top250movies)) {
    top250movies.na_prop(column = column)
  }
```

S'adverteix que la proporció de valors perduts no supera en cap cas el 18%. Per tant es procedeix amb la imputació per k-NN considerant a la resta de dades disponibles. 

```{r imputation}
# Imputació per k-NN
  for (column in colnames(top250movies)) {
    if (anyNA(top250movies[[column]])) {
      top250movies <- kNN(data = top250movies,
                          variable = column,
                          metric = 'grower',
                          imp_var = FALSE)
    }
  }
```

## Transformacions dicotòmiques

Es dicotomitza l'atribut 'Genre' i s'elimina la característica original.

```{r dichotomic}
# Genre
  genre_list <- unique(str_trim(unlist(strsplit(top250movies$Genre,
                                               split = ','))))
  genre_list <- genre_list[!is.na(genre_list)]
  
  for (genre in genre_list) {
    top250movies[[genre]] <- as.factor(top250movies.detect(column = 'Genre',
                                                           pattern = genre))
  }
  
  top250movies <- subset(x = top250movies,
                         select = -Genre)
```

## Generació de noves característiques

En base a les dades ja existents, s'obté els beneficis de la pel·lícula i si és rendible només si 'Collection' és, almenys, 2 vegades superior a 'Budget'.

```{r new data}
# Beneficis per pel·lícula
  top250movies$Net_income <- top250movies$Collection - top250movies$Budget

# Es comprova si la pel·lícula és rendible només si Collection és el doble que Budget
  top250movies$Profitable <- as.factor(top250movies.is_profitable(minimum_criteria = 2))
```

## Normalització

```{r standardization}
# Es normalitzen els atributs numèrics
  for (column in colnames(top250movies)) {
    if ((class(top250movies[[column]]) %in% c('numeric',
                                              'integer')) &
        (column != 'Year')) {
      top250movies[[paste(column,
                          '_z-score',
                          sep = '')]] <- scale(top250movies[[column]])
    }
  }
```


Presentem una instantànea del resultat final del dataset: 

```{r}
head(top250movies)
```


******
# Anàlisi de les dades.
******

## Aplica un model supervisat i un no supervisat a les dades i comenta els resultats obtinguts.

### Model supervisat

Triem un mètode de classificació per al model supervisat. Implementem a continuació un arbre de decisió per a crear regles que determinin si una pel·lícula és profitosa o no depenent de les variables independents. Per això, tenim les instàncies correctament etiquetades a la variable de classe dicotòmica "Profitable", generada a partir dels atributs "Budget" i "Collection". S'estima que una pel·lícla **és profitosa, si la recaudació dobla al pressupost destinat per a la seva producció**.

#### Preparació de les dades per al model

Per a la selecció de característiues, excloem, els atributs Títol, Director, Duració perquè hi ha molta varietat en les dades. Els camps Collection i Budget també els excloem perquè son atributs que deriven en la variable objectiu "Profitable".


Fem l'extració en un nou dataset, i conertim els camps lògics que determinen el gènere de la pel·licula a Numèric. A continuació presentem una mostra i fem un resum del subconjunt de dades:

```{r}


names <- colnames(top250movies)
exclude <- c('Duration', 'Budget', 'Collection', 'Net_income', 'Duration_z-score', 'Rating_z-score', 'Review_z-score', 'Budget_z-score', 'Collection_z-score', 'Net_income_z-score')

top250movies_id3b <- subset(x = top250movies,
                            select = names[!(names %in% exclude)])


```


Per validar l’arbre de decisió, és necessari dividir el conjunt de dades en un conjunt d’entrenament i un conjunt de test. El conjunt d’entrenament serà utilitzat per construir i afinar el model, mentre que el conjunt de test servirà per avaluar la seva precisió.


```{r}
set.seed(666)
y <- top250movies_id3b[,25] 
X <- top250movies_id3b[,c(1:24)]
```

De manera dinàmica, separem les dades en funció del paràmetre *split_prop* amb un valor de 3:

```{r}
split_prop <- 3 
indexes = sample(1:nrow(top250movies_id3b), size=floor(((split_prop-1)/split_prop)*nrow(top250movies_id3b)))
trainX<-X[indexes,]
trainy<-y[indexes]
testX<-X[-indexes,]
testy<-y[-indexes]
```

#### Creació del model
Per a crear l'arbre de decisió, fem ús de la funció C5.0 de la llibreria C50. Els paràmetres que necessita la funció són la matriu de camps predictors (el conjunt d’entrenament X) i el camp classificador (conjunt d’entrenament y):


```{r}
trainy = as.factor(trainy)
model <- C50::C5.0(trainX, trainy,rules=TRUE )
summary(model)
```

El paràmetre Errors mostra el número i percentatge de casos mal classificats en el subconjunt d’entrenament. classifica erròneament 23 dels 166 casos donats, una taxa d’error del 13.9%. A continuació, visualitzarem el model obtingut a partir de les regles:

```{r}

model <- C50::C5.0(trainX, trainy)
plot(model,gp = gpar(fontsize = 7.0))
```

De l'arbre resultant es conclou el següent:


+ En un **92%** dels casos, si la pel·licula és igual o anterior al 1975, i les ressenyes son iguals o inferiors a les 188000, aleshores, **NO ÉS PROFITOSA**.
+ En canvi, si és superior al 1975,  en un **87%** dels casos, la pel·lícula **ÉS PROFITOSA**, encara que el nombre de ressenyes sigui igual o inferior a les 188800.

+ En el cas de superar les 188000 ressenyes, la pel·lícula **ÉS PROFITOSA** en un **85%** dels casos.

Com hem comprovat, el conjunt de dades objecte de l'estudi, treu conclusions molt valuoses que no es poden deduir observant únicament el llistat de les 250 pel·lícules millor valorades per als usuaris d'IMDb.


### Model No supervisat

Per a l'estudi del model no supervisat prescindint inicialment de la variable etiquetada que defineix cada classe, i que en el nostre conjunt correspont a la variable dicotòmica *Profitable* (1 - Rendible/ 0 - No rendible)

Com no sabem d'inici el nombre d'agrupacions o classes naturals al que pertanyen les instàncies, farem us del mètode k-means per agrupar les observacions segons les variables independents disponibles. Per dur-ho a terme, s'ha hagut de normalitzar prèviament els atributs numèrics, i avaluarem diferents nombre de clústers (k) aplicant mètriques com SSW (*Sum of Squared Within*), SSB (*Sum of Squared Between*) i el coeficient de *Silhouette*.

+ **SSW** - Homogeneïtat entre grups. Minimització de distàncies intragrup. 
+ **SSB** - Heterogeneïtat entre grups. Maximizació de distàncies intragrup.
+ **Coeficient de Silhouette** - Intervals que indiquen si la mostra està al grup correcte.

Sabem que el nombre correcte de k és 2 perquè treballem amb una variable dicotòmica que determina les classes. A continuació estudiem diferents possibilitats.Per a procedir a aplicar el mètode *k-means*, avaluem diferents nombres de clústers (k) per a determinar l'agrupació òptima:

```{r}
#Seleccionem les variables d'interès i normalitzem
top250movies.all<-top250movies[,c('Profitable','Rating_z-score', 'Review_z-score', 'Budget_z-score', 'Collection_z-score')]
top250moviesNormalitzada <- as.data.frame(scale(top250movies.all[,c('Rating_z-score', 'Review_z-score', 'Budget_z-score', 'Collection_z-score')]))

# Avaluem k de 1 a 10
distance <- cluster::daisy(top250moviesNormalitzada)
valores <- seq(from=1, to=10, by=1)

# Resultats de les mètriques
resultats_ssw <- rep(NA, length(valores))
resultats_ssb <- rep(NA, length(valores))
resultats_silhouette <- rep(NA, length(valores))

for (k in valores[-1]) {
  set.seed(123)
  model <- stats::kmeans(top250moviesNormalitzada, centers=k)
  clusters <- model$cluster
  resultats_silhouette[k] <- summary(cluster::silhouette(
    clusters, distance))$avg.width
  resultats_ssw[k] <- model$tot.withinss
  resultats_ssb[k] <- model$betweenss
}
resultats_kmeans <- data.frame(valores, resultats_silhouette,
                             resultats_ssw, resultats_ssb) %>%
tidyr::drop_na()

```

Generem gràfics per a visualitzar les mètriques del *Coeficient de Silhouette*, *SSW* i *SSB* per ajudar a escollir el nombre idoni de clústers:

```{r}
# Gràfica del Coeficient de Silhouette
plot_silhouette<-ggplot(data=resultats_kmeans, mapping = aes(x=valores, y=resultats_silhouette))+scale_x_continuous(breaks=valores, minor_breaks = NULL)+
  geom_line(color='red', size=1)+
  geom_vline(aes(xintercept=2), color='green', linetype='dashed', size=1, alpha=0.75)+
  annotate('text',x=2, y=resultats_kmeans$resultats_silhouette[resultats_kmeans$valores==4], label='\n k',color='green', size=4, fontface='bold',hjust=0.0,vjust=0.75)+
  geom_point(color='blue',size=2)+labs(title = 'Gráfica del Coeficiente de Silhouette', x='nombre de clústers', y='silhoutte')

# Gràfica de Sum of Squared Within (SSW)
plot_ssw<-ggplot(data=resultats_kmeans, mapping = aes(x=valores, y=resultats_ssw))+scale_x_continuous(breaks=valores, minor_breaks = NULL)+scale_y_continuous(labels=scales::label_scientific(digits=2))+
  geom_line(color='red', size=1)+
  geom_vline(aes(xintercept=5), color='green', linetype='dashed', size=1, alpha=0.75)+
  annotate('text',x=5, y=resultats_kmeans$resultats_ssw[resultats_kmeans$valores==5], label='\n k',color='green', size=4, fontface='bold',hjust=0.0,vjust=0.75)+
  geom_point(color='blue',size=2)+labs(title = 'Gráfica de Sum of Squared Within (SSW)', x='nombre de clústers', y='SSW')

# Gràfica de Sum of Squared Between (SSB)
plot_ssb<-ggplot(data=resultats_kmeans, mapping = aes(x=valores, y=resultats_ssb))+scale_x_continuous(breaks=valores, minor_breaks = NULL)+scale_y_continuous(labels=scales::label_scientific(digits=2))+
  geom_line(color='red', size=1)+
  geom_vline(aes(xintercept=5), color='green', linetype='dashed', size=1, alpha=0.75)+
  annotate('text',x=5, y=resultats_kmeans$resultats_ssb[resultats_kmeans$valores==5], label='\n k',color='green', size=4, fontface='bold',hjust=0.0,vjust=0.75)+
  geom_point(color='blue',size=2)+labs(title = 'Gráfica de Sum of Squared Between (SSB)', x='nombre de clústers', y='SSB')

# Es combinen els gràfics en una figura annotada
annotate_figure(
  top = text_grob('k-means | Elecció del paràmetre k', face='bold', size=16),
  ggarrange(plot_silhouette, plot_ssw, plot_ssb, labels=c('A', 'B', 'C'), align='hv', nrow=3, ncol=1)
)

```


A. *Coeficient de Silhouette*: la gràfica mostra com s'ajusta cada punt al clúster assignat. Un valor alt indica que els punts estàn ajustats al seu propi grup i lluny dels veins. Hi ha un pic més pronunciat per a k=2 que apunta a que l'agrupació de 2 classes te un ajustament més adequat en comparació amb els altres valors de k.

B. *SSW*: la gràfica mesura les distàncies al quadrat de cada punt en un clúster al centroide del grup, indicador de la cohesió del clúster. Un valor menor indica que els punts estan més a prop del centroide, fet desitjable. D'acord amb el gràfic, el *SSW* disminueix significativament fins a k=5, i a partir d'aquí, els canvis son menys pronunciats, i no redueix substancialment la variació dins els clústers. 

C. *SSB*: la gràfica mesura la suma de les distàncies al quadrat entre els centroides dels clústers i el centroide global de tots els punts, reflectint la separació entre clústers. Un valor alt indica que els clústers estan més dispersos, i per tant millor definits. Al gràfic s'observa un agument a cada increment de k, però igual que passa amb el *SSW*, el canvi és menys pronunciat després de k=5. Això suggereix que a més clústers afegim, la millora no es tan evident després d'arribar als 5 clústers.

Sorprent els resultats de *SSW* i *SSB*, degut a que el nombre esperat de clústers és 2. Per entendre millor aquests resultats, visualitzem a continuació les agrupacions per a k=2 i K=5 en les diverses combinacions de variables disponibles.

Primer, creem els models *k-means*  per cada valor de k desitjat, i a continuació, utilitzem la funció per a crear els gràfics per a les diferents relacions de parells de variables per a k=2 i k=5:

```{r}
# Creem modelo K-means per a k=2 i k=5
set.seed(123)
k2_model <- kmeans(top250moviesNormalitzada, centers=2)
k5_model <- kmeans(top250moviesNormalitzada, centers=5)


# Llista de totesles combinacions de parells de variables:
variable_pairs <- combn(c('Rating_z-score', 'Review_z-score', 'Budget_z-score', 'Collection_z-score'), 2, simplify = FALSE)

# Llistes per a guardar els gràfics:
plots_k2 <- list()
plots_k5 <- list()

for(i in seq_along(variable_pairs)) {
  var1 <- variable_pairs[[i]][1]
  var2 <- variable_pairs[[i]][2]

  # Guardem els gràfics a les seves respectives llistes
  plots_k2[[i]] <- create_kmeans_plot(top250movies.all, k2_model, var1, var2, top250movies.all$Profitable)
  plots_k5[[i]] <- create_kmeans_plot(top250movies.all, k5_model, var1, var2, top250movies.all$Profitable)
}

# Exemple d'us de la funció amb plots_k2 i plots_k5
final_plot_k2 <- combine_plots_with_shared_legend(plots_k2)
final_plot_k5 <- combine_plots_with_shared_legend(plots_k5)

# Visualitsem els gràfics finals
print(final_plot_k2)

```


```{r}
print(final_plot_k5)
```


Com s'observa, el nombre de clústers més adient ésk=2. Per a k=5 hi ha classes que queden superposades. L'elecció de k=2 s'alinea amb la recomanació del coeficient de *Silhouette* que es tracta d'un indicador robust de la qualitat de l'agrupament, i encara que hi ha disminucions marginals per a *SSW* i augments marginals per a SSB després de k=2, aquests no justifiquen l'elecció d'un major nombre de clústers.


## Aplica una prova per contrast d'hipòtesi. 
*Tingues en compte que algunes d'aquestes proves requereixen verificar prèviament la normalitat i homocedasticitat de les dades.*

Es vol estudiar si la proporció de pel·lícules rendibles és major quan el pressupost d'aquestes és superior a la mitjana, *high*, al 99% de confiança.

```{r contrast, echo = FALSE, fig.cap = 'Proporció de pel·lícules rendibles per pressupost', fig.align = 'center'}
# S'obté la taula
  addmargins(table(top250movies$Profitable, factor(x = top250movies$Budget >= mean(top250movies$Budget),
                                                   levels = c(FALSE, TRUE),
                                                   labels = c('Low', 'High')),
                   dnn = c('Profitable', 'Budget')))

# Es grafica el constrast
  ggplot(data = top250movies,
         aes(x = Budget > mean(Budget),
             fill = Profitable,
             by = Budget > mean(Budget))) +
    stat_count(geom = 'bar',
               position = 'stack') +
    geom_text(stat = 'prop',
              position = position_stack(vjust = 0.5)) +
    theme(axis.ticks.y = element_blank(),
          axis.text.y = element_blank()) +
    scale_x_discrete(labels = c('Low', 'High')) +
    labs(title = 'Profitable movies proportion by budget',
         x = 'Budget',
         y = element_blank())
```

## Hipòtesi nul·la i alternativa

$H_{0}: \frac{p_{1}}{p_{2}} = 1$

$H_{1}: \frac{p_{1}}{p_{2}} > 1$

$p_{1} :=
\text{proporció problacional de pel·lícules rendibles amb pressupost superior o igual a la mitjana mostral}$

$p_{2} :=
\text{proporció problacional de pel·lícules rendibles amb pressupost inferior a la mitjana mostral}$

## Test estadístic

El test que s'empra en aquest apartat és el contrast de la proporció, o el contrast de dades categòriques corregit, de dues mostres per a la cua superior on es compleix que, sota $H_{0}$:

$$
x^{2\space*} = \sum_{i}\sum_{j} \frac{(| O_{ij} - E_{ij} | - 0.5)^2}{E_{ij}} \sim X^{2}_{1}
$$

## Contrast

```{r contrast calculation}
# Es calculen els paràmetres
  group_1 <- subset(x = top250movies,
                    subset = Budget >= mean(Budget),
                    select = Profitable,
                    drop = TRUE)
  group_2 <- subset(x = top250movies,
                    subset = Budget < mean(Budget),
                    select = Profitable,
                    drop = TRUE)
  
  x_1 <- sum(as.numeric(group_1) - 1)
  x_2 <- sum(as.numeric(group_2) - 1)
            
  n_1 <- length(group_1)
  n_2 <- length(group_2)

# Es calcula el test
  test <- prop.test(x = c(x_1, x_2),
                    n = c(n_1, n_2),
                    alternative = 'greater',
                    conf.level = 0.99)
  
# S'obté l'estadístic
  x2 <- test$statistic[[1]]
```

```{r contrast visualization, echo = FALSE, fig.cap = 'Contrast de cua superior de la distribució Chi quadrat', fig.align = 'center'}

f2 <- function(x){
  y <- dchisq(x,
              df = 1)
  y[x < qchisq(p = 0.01,
               df = 1,
               lower.tail = FALSE)] <- NA
  return(y)
}

ggplot(data.frame(x = c(2, 12)),
       aes(x = x)) +
  stat_function(fun = f2,
                geom = 'area',
                fill = 'red') +
  stat_function(fun = dchisq,
                args = list(df = 1)) +
  geom_point(aes(x = x2,
                 y = 0),
             color = 'blue') +
    geom_text(aes(x = 8,
                  y = -0.005,
                  color = 'red'),
              label = '-> Rejection region',
              show.legend = FALSE) +
  geom_text(aes(x = x2,
                y = -0.005),
            label = 'x2*') +
  labs(title = 'Chi squared test',
       y = 'Probability',
       x = 'x2')
```

## Interpretació

El resultat obtingut permet rebutjar $H_{0}$ amb $\alpha = 0.01$.

S'observa en el gràfic que $x^{2\space*}$ és troba situat dins la zona de rebuig, és a dir, que és superior al valor crític en aquest cas particular i, en conseqüència, amb les dades disponibles, es demostra estadísticament, que la proporció de pel·lícules rendibles és major en el conjunt de metratges que sobrepassen el pressupost promig respecte als altres.


******
# Representació dels resultats a partir de taules i gràfiques.
******

Les gràfiques del conjunt de dades, es presenten al llarg dels apartats. En aquesta secció, mostrem una taula resum que ens ajudi a tenir una visió general i tècnica dels resultats de l’estudi:


<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <td class="tg-0lax">**Apartat**</td>
    <td class="tg-0lax">**Resultat (valor observat, crític, valor p...)** </td>
    <td class="tg-0lax">**Conclusió/ Valoració**</td>
  </tr>
  <tr>
    <td class="tg-0lax">1. Descripció del dataset</td>
    <td class="tg-0lax">250 observacions i 10 característiques variades</td>
    <td class="tg-0lax">Disposem d'un conjunt de dades ben estructurades d'un ranking de valoracions de les top 250 pel·lícules que preten donar resposta a la pregunta de si les valoracions, pressupostos, i altres característiques determinen el grau de rendibilitat que genera</td>
  </tr>
  <tr>
    <td class="tg-0lax">2. Selecció de dades </td>
    <td class="tg-0lax">Eliminació de Title, Classification, Director</td>
    <td class="tg-0lax">Es decideix prescindir d'aquestes característiques perquè l'estudi es vol fer de forma agragada, i aquestes variables presenten gairebé resultats diferents per a cada instància.</td>
  </tr>
  <tr>
    <td class="tg-0lax">3. Neteja de les dades</td>
    <td class="tg-0lax">Missing Values: Budget: 16% /Collection: 17.6%<br> Profitable = Si( Collection - Budget*2> 0 , 1, 0)</td>
    <td class="tg-0lax">A part de depurar text, S'imputen pel mètode de veïnatge *kNN* valors perduts i extrems per a a totes les variables, especialment  Budget i Collection per l'alt volum en comparació a la resta. Addicionalment, es transformen tipus de dades, s'unifica el tipus de moneda i es normalitzen variables numèriques. Finalment, es crea la variable de classe Profitable que mostra 1 si la recaudació de la pel·lícula dobla com a mínim el pressupost</td>
  </tr>
  <tr>
    <td class="tg-0lax">4. Anàlisi de les dades </td>
    <td class="tg-0lax">-</td>
    <td class="tg-0lax">-</td>
  </tr>
  <tr>
    <td class="tg-0lax">4.1.1 Model supervisat - Arbre de decisió</td>
    <td class="tg-0lax">Rule 1: Year <= 1975;  Review <= 188000;  class 0  92%<br>Rule 2: Year > 1975;  class 1  87%<br>Rule 3: Review > 188000; class 1  85%</td>
    <td class="tg-0lax">taxa d'error del 13.9%.</td>
  </tr>
  <tr>
    <td class="tg-0lax">4.1.2 Model No Supervisat - *k-means*</td>
    <td class="tg-0lax">k=2</td>
    <td class="tg-0lax">Utilitzant Coeficient de *Silhouette* es confirma que la relació de parells de variables mostren dues classes diferenciades </td>
  </tr>
  <tr>
    <td class="tg-0lax">4.2 Prova per contrast d'hipòtesi.</td>
    <td class="tg-0lax">H_0:p1/p2=1 <br> H_>_1:p1/p2>1<br>H_0 amb α=0.01</td>
    <td class="tg-0lax">Es demostra estadísticament, que la proporció de pel·lícules rendibles és major en el conjunt de metratges que sobrepassen el pressupost promig respecte als altres.</td>
  </tr>
</thead>
</table>



******
# Resolució del problema.
******

*A partir dels resultats obtinguts, quines són les conclusions? Els resultats permeten respondre al problema?*

# Exportació del conjunt de dades

```{r dataset export}
# S'exporta top250movies
  write.csv(x = top250movies,
            file = 'top250movies_clean.csv',
            row.names = FALSE)
```

